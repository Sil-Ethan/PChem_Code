# -*- coding: utf-8 -*-
"""CHL Ising_Model.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1PNtW1B5qk8g7BlhsZ1v_uEs8Xt8VvrqD

<h1>Chapter 12: The 2D Ising Model<h1>

There is a lot of useful input in this notebook, but some of the animated cells take a while to run.  Do NOT use "run all" for this notebook, rather go through in order and try to understand what each cell is doing.

The headings below match the sections from Schrier Ch. 12 and the inputs are meant to recapitulate in Python what he did originally in Mathematica.
"""

import numpy as np
from matplotlib import pyplot as plt
import matplotlib as mpl
import sympy as sy



"""<h2>12.1 Description of the Model<h2>

<h2>12.2 Computational Implementation<h2>

<h3>12.2.1 Representing spin configurations as lists<h3>

(the lists are numpy arrays here)
"""

example = np.array([[1,2],[3,4]])

print(example)

"""Here is how to make graphical versions of arrays using a color map (here it's grayscale) for the numbers that appear in the arrays: this will be useful for making graphical representations of the Ising model."""

def arrayPlot(array,vmin=0,vmax=None):
    """A python version of the ArrayPlot[] function in Mathematica"""
    fig, ax = plt.subplots()
    ax.set_yticklabels([])
    ax.set_xticklabels([])
    ax.imshow(array,cmap='Greys',vmin=vmin,vmax=vmax)
    plt.show()

arrayPlot(example)

example[0] #remember that python starts counting from zero, not one.

example[0,0] #remember that python starts counting from zero, not one.

example[0,1] #remember that python starts counting from zero, not one.

row, col = np.random.randint(0,2,2) #this selects two random integers between 0 and 1
#(arguments np.random.randint are low limit, high limit exclusive, amount randomly selected)

example[row,col] #selects a random element of the array that is indexed by the random numbers from above

"""<h3>12.2.2 Generating initial configurations<h3>"""

nSize = 6
allUpConfig = np.array([[1 for i in range(nSize)] for j in range(nSize)])
# a reproduction of what Table[] does in Mathematica
print(allUpConfig)

arrayPlot(allUpConfig,-1,1)

randomConfig = np.array([[(-1)**np.random.randint(2) for i in range(nSize)] for j in range(nSize)])
# a reproduction of what Table[] does in Mathematica
arrayPlot(randomConfig,-1,1)

checkerboardConfig = np.array([[(-1)**(row+col) for row in range(nSize)] for col in range(nSize)])
arrayPlot(checkerboardConfig,-1,1)

"""<h3>12.2.3 Computing properties: Magnetization<h3>

The "Magnetization" in an Ising model is basically a count of how many different kinds of state there are: the original Ising lattice model just had spins up and spins down, which add up to some net "magnetization" across the model.
"""

def netMagnetization(config):
  """Python version of the first netMagnetization[] function Schrier writes"""
  total = 0
  for row in config:
      for element in row:
          total+= element
  return total

netMagnetization(allUpConfig)

netMagnetization(checkerboardConfig)

def netMagnetization(config):
    """Python version of the second netMagnetization[] function Schrier writes
    automatically includes summation over all levels of the array"""
    return np.sum(config)

(netMagnetization(allUpConfig),netMagnetization(checkerboardConfig))

def netMagnetizationPerSpin(config):
  """Python version of net magnetization function"""
  return netMagnetization(config)/len(config)**2

(netMagnetizationPerSpin(allUpConfig),netMagnetizationPerSpin(checkerboardConfig))

netMagnetizationPerSpin(randomConfig) #try this for a few randomConfig to see whether it changes; it should

"""<h3>12.2.4 Computing properties: Energy<h3>

The total energy of the Ising model has to be counted step by step across the whole array and depends on rules that can vary: here the parameters "J" and "B" tell you how strongly the spins interact with each other and how big the difference in energy between the two states is, respectively. The energy rules can change based on those two parameters and also based on how the system is defined (i.e. whether it has walls or not).
"""

def energyIsing2D(config,J,B):
    """
    Function for calculating the energy of an Ising Model.
    Requires a config (the Ising Model in question), a value of J (interaction parameter)
    and a value for B (external field parameter)
    """
    energyB,energyJ = 0,0 # Initializes local variables
    for row in range(len(config)): # Loop over rows
        for col in range(len(config)): # Simultaneously loop over columns
            energyB += B*config[row,col]
            if row>0: # Up
                energyJ += J*config[row-1,col]*config[row,col]
            if row<len(config)-1: # Down
                energyJ += J*config[row+1,col]*config[row,col]
            if col>0: # Left
                energyJ += J*config[row,col-1]*config[row,col]
            if col<len(config)-1: # Right
                energyJ += J*config[row,col+1]*config[row,col]
    return energyB + energyJ/2 # Removes double counting

energyIsing2D(checkerboardConfig,1,0)

energyIsing2D(checkerboardConfig,-1,0)

energyIsing2D(allUpConfig,0,1)

def energyPerSpin(config,J,B,energyFunction):
    """"calculate the energy per spin based on a
    particular ising model configuation "config",
    an interaction parameter "J"
    an external field parameter "B"
    and a function for calculating the energy"""
    return energyFunction(config,J,B)/len(config)**2

(energyPerSpin(checkerboardConfig,1,0,energyIsing2D),
energyPerSpin(checkerboardConfig,-1,0,energyIsing2D),
energyPerSpin(allUpConfig,0,1,energyIsing2D))

"""<h2>12.3 Metropolis Monte Carlo Simulation<h2>

<h3>12.3.1 Basic implementations<h3>
"""

def MCstep(kT,J,B,config):
    """functions for taking a single Monte Carlo step"""
    newConfig = config.copy() #def local variables
    row,col = np.random.randint(0,len(config),2) #pick random spin

    #calculate the energy **before the change**
    Estart = config[row,col]*B
    if row>0: # Up
        Estart += J*config[row-1,col]*config[row,col]
    if row<len(config)-1: # Down
        Estart += J*config[row+1,col]*config[row,col]
    if col>0: # Left
        Estart += J*config[row,col-1]*config[row,col]
    if col<len(config)-1: # Right
        Estart += J*config[row,col+1]*config[row,col]

    #a single spin flip multiplies the local energy by -1
    Eend = -Estart

    if Eend < Estart: #did energy decrease?
      newConfig[row,col] *= -1 # Then flip the spin
    else:
      if np.random.random() <= np.exp(-(Eend-Estart)/kT): # If a random number is less than the probability
        newConfig[row,col] *= -1 # Then flip the spin

    return newConfig

def runMCmovie(kT,J,B,MCstepFunction, ax):
    """a python version of the runMCmovie function"""
    config = checkerboardConfig.copy()
    trajectory = []
    for i in range(1500):
        config = MCstepFunction(kT,J,B,config)
        ax.set_yticklabels([])
        ax.set_xticklabels([])
        arrayplot = [ax.imshow(config,cmap='Greys',
                               vmin=-1,vmax=1, animated=True)]
        trajectory.append(arrayplot)
    return trajectory #a list of arrayplot outputs

from matplotlib import rc
rc('animation', html='jshtml')

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib notebook
import matplotlib.animation as animation

fig1, ax = plt.subplots()
images = runMCmovie(10,-1,0,MCstep, ax)

ani = animation.ArtistAnimation(fig1, images, interval=1000/50, blit=True)

#ignore the error message

ani #heads up this can take up to 5 minutes
#click the right arrow button below the frame to run the movie

def runMC(kT, J, B, nEquil, nDataCol, sampleInterval, config, MCstepFunction, energyFunction):
    """function to run the Ising model MC simulation and collectsamples"""
    Esamples = []
    Msamples = []
    newConfig = config.copy()
    for i in range(nEquil):
        newConfig = MCstepFunction(kT, J, B, newConfig)
    for i in range(nDataCol):
        newConfig = MCstepFunction(kT, J, B, newConfig)
        if i % sampleInterval == 0:
            Esamples.append(energyFunction(newConfig,J,B))
            Msamples.append(abs(netMagnetizationPerSpin(newConfig)))
    Esamples = np.array(Esamples)
    Msamples = np.array(Msamples)
    return [Esamples.mean()/len(config)**2, # Mean Energy per spin
           Esamples.var()/(len(config)**2*kT**2), # Heat Capacity per spin
           Msamples.mean(), # Average net magnetization per spin
           newConfig] # The Final configuration

EPerSpin,heatCap,netMagPerSpin,finalConfig = runMC(1,-1,0,10000,200000,1000,checkerboardConfig,MCstep,energyIsing2D)

print('The average energy is:', EPerSpin)
print('The heat capacity is:', heatCap)
print('The net magnetization is:', netMagPerSpin)

arrayPlot(finalConfig,-1,1)

finalConfig

"""<h2>12.4 Generalization<h2>

<h3>12.4.1 Periodic boundary conditions<h3>
"""

def energyIsing2DPBC(config, J, B):
    """energy of an Ising model with Periodic Boundary Conditions"""
    energyB = 0
    energyJ = 0
    for row in range(len(config)):
        for col in range(len(config)):
            energyB += B*config[row,col]
            if row>0: # Up
                energyJ += J*config[row-1,col]*config[row,col] # Interior
            else:
                energyJ += J*config[len(config)-1,col]*config[row,col] # Periodic boundary conditions
            if row<len(config)-1: # Down
                energyJ += J*config[row+1,col]*config[row,col] # Interior
            else:
                energyJ += J*config[0,col]*config[row,col] # Periodic boundary conditions
            if col>0: # Left
                energyJ += J*config[row,col-1]*config[row,col] # Interior
            else:
                energyJ += J*config[row,len(config)-1]*config[row,col] # Periodic boundary conditions
            if col<len(config)-1: # right
                energyJ += J*config[row,col+1]*config[row,col] # Interior
            else:
                energyJ += J*config[row,0]*config[row,col] # Periodic boundary conditions
    return energyB+(energyJ/2) # Remove double counting and return final result

(energyPerSpin(checkerboardConfig,1,0,energyIsing2DPBC),
energyPerSpin(checkerboardConfig,-1,0,energyIsing2DPBC),
energyPerSpin(allUpConfig,0,1,energyIsing2DPBC))

def MCstepPBC(kT,J,B,config):
    """MC step for Periodic Ising Model"""
    newConfig = config.copy()
    row,col = np.random.randint(0,len(config),2)
    Estart = config[row,col]*B
    if row>0: # Up
        Estart += J*config[row-1,col]*config[row,col] # Interior
    else:
        Estart += J*config[len(config)-1,col]*config[row,col] # Periodic boundary conditions
    if row<len(config)-1: # Down
        Estart += J*config[row+1,col]*config[row,col] # Interior
    else:
        Estart += J*config[0,col]*config[row,col] # Periodic boundary conditions
    if col>0: # Left
        Estart += J*config[row,col-1]*config[row,col] # Interior
    else:
        Estart += J*config[row,len(config)-1]*config[row,col] # Periodic boundary conditions
    if col<len(config)-1: # right
        Estart += J*config[row,col+1]*config[row,col] # Interior
    else:
        Estart += J*config[row,0]*config[row,col] # Periodic boundary conditions
    Eend = -Estart

    if Eend < Estart: #did energy decrease?
      newConfig[row,col] *= -1 # Then flip the spin
    else:
      if np.random.random() <= np.exp(-(Eend-Estart)/kT): # If a random number is less than the probability
        newConfig[row,col] *= -1 # Then flip the spin

    return newConfig # Return the potentially altered array

EPerSpin,heatCap,netMagPerSpin,finalConfig=runMC(10,-1,0,10000,200000,1000,checkerboardConfig,MCstepPBC,energyIsing2DPBC)

print('The average energy is:', EPerSpin)
print('The heat capacity is:', heatCap)
print('The net magnetization is:', netMagPerSpin)

arrayPlot(finalConfig) # Show final configuration of simulation using periodic boundary conditions

def MCstepConstN(kT,J,B,config):
    newConfig=config.copy()
    configDidChange=False
    rowA,colA,rowB,colB=np.random.randint(1,len(config),4)

    spinA = config[rowA,colA]
    spinB = config[rowB,colB]

    if spinA != spinB: # Only do MC procedure if something charged
        newConfig[rowA,colA] = spinB # First, interchange the spins
        newConfig[rowB,colB] = spinA
        Estart = energyIsing2D(config,J,B) # Get configuration energies
        Eend = energyIsing2D(newConfig,J,B)
        if Eend<Estart or np.random.random()<np.exp(-(Eend-Estart)/kT): # Did the energy decrease or it randomly increases in energy?
            configDidChange = True
    if configDidChange: # Did the configuration change uring this process
        return newConfig # configDidChange==True, so return the new spin config
    return config # Otherwise, return the original spin configuration

EPerSpin,heatCap,netMagPerSpin,finalConfig=runMC(10,-1,0,10000,200000,1000,checkerboardConfig,MCstepConstN,energyIsing2DPBC)

print('The average energy is:', EPerSpin)
print('The heat capacity is:', heatCap)
print('The net magnetization is:', netMagPerSpin) # should be zero if constant N with equal numbers

arrayPlot(finalConfig) # Final configuration of constant N simulation

"""Below is some code not in Schrier for making movies of simulations in the differently defined systems: this uses matplotlib animation tools to make the movies."""

# Commented out IPython magic to ensure Python compatibility.
#original
# %matplotlib notebook
import matplotlib.animation as animation

fig1, ax = plt.subplots()
images = runMCmovie(10,-1,0,MCstepPBC, ax)

ani1 = animation.ArtistAnimation(fig1, images, interval=1000/50, blit=True)

ani1 #takes a little computational time to actually make the movie

# Commented out IPython magic to ensure Python compatibility.
#periodic boundary conditions

# %matplotlib notebook
import matplotlib.animation as animation

fig2, ax = plt.subplots()
images = runMCmovie(10,-1,0,MCstepPBC, ax)

ani2 = animation.ArtistAnimation(fig2, images, interval=1000/50, blit=True)

ani2 #again, takes a little while to show

# Commented out IPython magic to ensure Python compatibility.
#constant particle number

# %matplotlib notebook
import matplotlib.animation as animation

fig3, ax3 = plt.subplots()
images3 = runMCmovie(10,-1,0,MCstepConstN, ax3)
ani3 = animation.ArtistAnimation(fig3, images3, interval=1000/50, blit=True, repeat_delay=500)

ani3

"""<h3>12.4.3 Further generalizations<h3>

<h2>12.5 Looking Forward<h2>
"""